#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
/* variables */
const ll MAXN = 1e5 + 5,inf = 1e9 + 7;
vector<ll> g[MAXN];
ll timer = 0;
bool vis[MAXN]; ll lg[2*MAXN];
ll tin[MAXN],ett[2*MAXN],depth[MAXN],sz[MAXN],par[MAXN],best[MAXN];
ll st[2*MAXN][19]; // sparse table
/* functions */
void rmq(){
    lg[0] = -1;
    for (int i = 1 ; i <= timer ; i++){
        lg[i] = lg[i/2] + 1;
        st[i][0] = ett[i];
    }
    for (int j = 1 ; j <= 18 ; j++){
        for (int i = 1 ; i + (1 << j) - 1 <= timer ; i++){
            st[i][j] = min(st[i][j-1],st[i + (1 << (j - 1))][j-1]);
        }
    }
}
ll find_size(ll node = 1,ll p = 0){
    if (vis[node]) return 0;
    sz[node] = 1;
    for (auto v : g[node]){
        if (v != p && !vis[v]){
            sz[node] += find_size(v,node);
        }
    }
    return sz[node];
}
ll find_centroid (ll node,ll p,ll n){
    for (auto v : g[node]){
        if (v != p){
            if (!vis[v] && sz[v] > n/2){
                return find_centroid(v,node,n);
            }
        }
    }
    return node;
}
void centroid_decomp(ll node = 1,ll p = 0){
    find_size();
    ll c = find_centroid(node,0,sz[node]);
    vis[node] = true; par[c] = p;
    for (auto v : g[node]){
        if (!vis[v]){
            centroid_decomp(v,c);
        }
    }
}
void euler(ll u = 1, ll p = 0){
    depth[u] = depth[p] + 1;
    ett[++timer] = depth[u];
    tin[u] = timer;
    for (auto v : g[u]){
        if (v != p){
            euler(v,u);
            ett[++timer] = depth[u];
        }
    }
}
ll n,m;
void mark(ll node){
    if (best[node] == 0) return;
    ll pos = node;
    while (pos){
        ll r = max(tin[pos],tin[node]),l = min(tin[pos],tin[node]);
        ll j = lg[r-l+1];
        best[pos] = min(best[pos], (depth[pos] + depth[node] - 2 * min(st[l][j], st[r - (1 << j) + 1][j])));
        pos = par[pos];
    }
}
ll get_dist(ll node){
    ll pos = node,ans = inf;
    while (pos){
        ll r = max(tin[pos],tin[node]),l = min(tin[pos],tin[node]);
        ll j = lg[r-l+1];
        ans = min(ans, best[pos] + (depth[pos] + depth[node] - 2 * min(st[l][j], st[r - (1 << j) + 1][j])));
        pos = par[pos];
    }
    return ans;
}
signed main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m;
    depth[0] = 0;
    memset(vis,false,sizeof(vis));
    for (int i = 1 ; i < n ; i++){
        ll u,v;
        cin >> u >> v;
        g[u].pb(v);
        g[v].pb(u);
    }
    memset(best,inf,sizeof(best));
    euler(); centroid_decomp();
    rmq(); mark(1);
    while (m--){
        ll opt,node;
        cin >> opt >> node;
        if (opt == 1) {
            mark(node);
        }
        else {
            cout << get_dist(node) << endl;
        }
    }
}