/*                 thisiscaau's  code              
        What’s happened happened. Which is an expression of faith 
    in the mechanics of the world. It’s not an excuse to do nothing.
*/
/* shortcuts */
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define fi first
#define se second
#define pb push_back
#define mp make_pair
typedef pair<ll,ll> ii;
typedef vector<ii> vii;
/* constants */
ll const inf = 1e9 + 7, MAXN = 5e5 + 5;
/* declaration */
ll n;
ll a[MAXN],st[4*MAXN];
priority_queue<ll,vector<ll>,greater<ll>> pq;
/* workspace */
void build(ll node,ll l,ll r){
    if (l == r){
        st[node] = -inf;
        return;
    }
    ll m = (l+r)/2;
    build(node*2,l,m);
    build(node*2+1,m+1,r);
    st[node] = max(st[node*2],st[node*2+1]);
}
void update(ll node,ll l,ll r,ll idx,ll val){
    if (l > idx || r < idx) return;
    if (l == r){
        st[node] = max(st[node],val);
        return;
    }
    ll m = (l+r)/2;
    update(node*2,l,m,idx,val);
    update(node*2+1,m+1,r,idx,val);
    st[node] = max(st[node*2],st[node*2+1]);
}
ll query(ll node,ll tl,ll tr,ll l,ll r){
    /* out of range */
    if (tl > r || tr < l){
        return -inf;
    }
    if (tl >= l && tr <= r){
        return st[node];
    }
    ll tm = (tl+tr)/2;
    return max(query(node*2,tl,tm,l,r),query(node*2+1,tm+1,tr,l,r));
}
void solve(){
    cin >> n;
    for (int i = 1 ; i <= n ; i++){
        cin >> a[i];
        a[i]++; // leave space for 0 
    }
    a[0] = 1;
    build(1,1,n+1); /* reset */
    for (int i = 0 ; i <= n ; i++){
        ll dp = query(1,1,n+1,1,a[i]);
        dp = max(0ll,dp) + 1;
        /* update numbers that consider a[i] as nearest larger number */
        while (!pq.empty()){
            ll previous = pq.top();
            if (previous > a[i]) break;
            pq.pop();
            update(1,1,n+1,previous,query(1,1,n+1,previous,previous)+1); // update
        }
        update(1,1,n+1,a[i],dp); // update
        pq.push(a[i]); // push
    }
    cout << st[1] - 1 << endl;
}
signed main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    ll t;
    cin >> t;
    while (t--){
        solve();
    }
}
/* Explanation
Ta sẽ chia bài toán thành các bài toán con nhỏ hơn.
Tại một thời điểm bất kỳ ta cần phải để tâm đến 2 yếu tố đó chính là index và
số nhỏ hơn trong cặp cuối cùng của dãy được build bởi vì khi muốn thêm 1 phần tử
vào subsequence này chúng là sẽ chỉ cần nó >= phần tử min này.
Có thể dùng sol n^2 hay j đó những sẽ tle sml nên chúng ta sẽ tiếp cận bằng cách
dùng segment tree xem code ở trên để hiểu tôi lười okay.
Time complexity : O(n log n) đủ AC :v
*/